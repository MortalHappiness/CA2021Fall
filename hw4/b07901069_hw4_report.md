# Hw4 Report

B07901069 電機四 劉奇聖

## Modules Explanation

### `Adder.v`

Adder module reads two 32 bits signed integer as inputs and output the sum of these two integers. This module directly assign the sum of these two integers to output.

### `MUX32.v`

MUX32 module reads two 32 bits data and a select signal as input, and outputs one of these two data based on the select signal. This module directly assigns the output wire with the verilog ternary conditional operator. If the select signal is 1, output data 2. Else output data 1.

### `Sign_Extend.v`

Sign_Extend module reads one 12 bit data as input, and outputs its sign-extended 32 bit data as output. This module repeats `data[11]` 20 times and concatenates it with original data to form a 32 bit data and assigns it to the output wire.

### `Control.v`

Control module reads 7 bit opcode as input, and outputs 2 bit ALUOp, 1 bit ALUSrc and 1 bit RegWrite signals. This module assigns ALUOp to `2'b10` if `Op_i[5]` is 1 else assigns it to `2'b11` since the only difference between R type and I type instructions is `Op_i[5]`. This module assigns ALUSrc to 0 if `Op_i[5]` is 1 else assigns it to 1. This module assigns RegWrite to 1 since both I type and R type instructions needs to write data to registers.

### `ALU_Control.v`

ALU_Control module reads 10 bit `funct_i` as input, this input is generated by concatenating `funct7` and `funct3`. This module also reads 2 bit ALUOp and outputs 3 bit ALUCtrl signal. This module first separate `funct7` and `funct3` from `funct_i`. Next assign `ALUCtrl_o` based on `ALUOp_i`, `funct7`, and `funct3`.

If `ALUOp_i` is equal to `10` and `funct7` is equal to `0000000` and `funct3` is equal to `111`, then assign `ALUCtrl_o` with `ALU.ALU_AND`.
If `ALUOp_i` is equal to `10` and `funct7` is equal to `0000000` and `funct3` is equal to `100`, then assign `ALUCtrl_o` with `ALU.ALU_XOR`.
If `ALUOp_i` is equal to `10` and `funct7` is equal to `0000000` and `funct3` is equal to `001`, then assign `ALUCtrl_o` with `ALU.ALU_SLL`.
If `ALUOp_i` is equal to `10` and `funct7` is equal to `0000000` and `funct3` is equal to `000`, then assign `ALUCtrl_o` with `ALU.ALU_ADD`.
If `ALUOp_i` is equal to `10` and `funct7` is equal to `0100000` and `funct3` is equal to `000`, then assign `ALUCtrl_o` with `ALU.ALU_SUB`.
If `ALUOp_i` is equal to `10` and `funct7` is equal to `0000001` and `funct3` is equal to `000`, then assign `ALUCtrl_o` with `ALU.ALU_MUL`.
If `ALUOp_i` is equal to `11` and `funct3` is equal to `000`, then assign `ALUCtrl_o` with `ALU.ALU_ADD`.
If `ALUOp_i` is equal to `11` and `funct7` is equal to `0100000` and `funct3` is equal to `101`, then assign `ALUCtrl_o` with `ALU.ALU_SRA`.

### `ALU.v`

ALU module reads two 32 bit signed integers and 3 bit ALUCtrl as input, and outputs one 32 bit signed integer and one 1 bit zero signal. This module assigns `data_o` to different output based on `ALUCtrl`. This module assigns `Zero_o` to 1 if `ALUCtrl_i` is equal to `ALU_SUB` and `data1_i` is equal to `data_2_i` else 0.

If `ALUCtrl_i` is equal to `ALU_AND`, then assigns `data_o` with the bitwise and of `data1_i` and `data2_i`.
If `ALUCtrl_i` is equal to `ALU_XOR`, then assigns `data_o` with the bitwise xor of `data1_i` and `data2_i`.
If `ALUCtrl_i` is equal to `ALU_SLL`, then assigns `data_o` with `data1_i` logically left shift by `data2_i` bits.
If `ALUCtrl_i` is equal to `ALU_ADD`, then assigns `data_o` with `data1_i + data2_i`.
If `ALUCtrl_i` is equal to `ALU_SUB`, then assigns `data_o` with `data1_i - data2_i`.
If `ALUCtrl_i` is equal to `ALU_MUL`, then assigns `data_o` with `data1_i * data2_i`.
If `ALUCtrl_i` is equal to `ALU_SRA`, then assigns `data_o` with `data1_i` arithematically right shift by `data2_i[4:0]` bits.

### `CPU.v`

CPU module reads clock signals, reset bit, and start bit as input. This module only declare wires and assign them to each submodules based on the data path figure.

This module extract `funct7`, `RS2addr`, `RS1addr`, `funct3`, `RDaddr`, `opcode` from the `instruction` wire.

Connect `opcode`, `ALUOp`, `ALUSrc`, `RegWrite` wire to `Control` module.

Connect `pc_o` wire to `data1_in` of the `Adder` module.
Connect constant `4` to `data2_in` of the `Adder` module.
Connect `pc_i` wire to `data_o` of the `Adder` module.

Connect `clk_i`, `rst_i`, `start_i`, `pc_i`, `pc_o` wires to `PC` module.

Connect `pc_o`, `instruction` wire to `Instruction_Memory` module.

Connect `clk_i`, `RS1addr`, `RS2addr`, `RDaddr`, `RDdata`, `RegWrite`, `RS1data`, `RS2data` to `Registers` module.

Connect `RS2ata`, `SignExtend_o`, `ALUSrc`, `Mux_o` to `MUX32` module.

Connect `instruction[31:20]` and `SignExtend_o` to `Sign_Extend` module.

Connect `RS1data`, `Mux_o`, `ALUCtrl`, `RDdata` to `ALU` module.

Connect `funct_i`, which is the concatenation of `funct7` and `funct3`, and `ALUOp`, `ALUCtrl` to `ALU_Control` module.

## Development Environment

My OS is "Linux Mint 20.2 Cinnamon". The compiler is `iverilog` version 10.3. I use VsCode to write this homework.
